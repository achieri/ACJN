"FNAM11", "TOYB4", "CEED4", "ALMI11", "EUCA4", "GPCP3", "ENGI4", "KNRE11", "MMXM11", "SLED3", "BRIV3", "OSXB3", "SLED4", "BAHI3", "BMEB3", "BTOW3", "FNOR11", "BTTL3", "IDVL3", "ENEV3", "GRLV11", "PSSA3", "PETR4", "WHRL4", "TOYB3", "DTEX3", "BRML3", "HGTX3", "BRDT3", "CYRE3", "RAPT3", "REDE3", "PETR3", "CCXC3", "RAPT4", "TECN3", "LPSB3", "TRPN3", "ATTB34", "AZEV4", "TAEE4", "WPLZ11B", "AZUL4", "BRFS3", "HYPE3", "CGRA3", "TEND3", "SANB3", "BGIP4", "VVAR4", "BPAN4", "TCNO3", "SANB4", "BBSE3", "UNIP6", "AALR3", "VVAR11", "ECOR3", "CARD3", "ENGI11", "TGMA3", "PLRI11", "MPLU3", "SANB11", "FIXX11", "ESTC3", "SAPR4", "VULC3", "CVCB3", "XPOM11", "QUAL3", "VVAR3", "EMBR3", "BRIV4", "DOMC11", "BBRC11", "BEEF3", "SLCE3", "CMIG4", "HTMX11", "BRIN3", "KROT3", "EZTC3", "HCRI11", "BKBR3", "CRFB3", "SUZB3", "CZLT33", "TWXB34", "DASA3", "STBP3", "WIZS3", "BRAP3", "COPH34", "MULT3", "NSLU11", "SULA11", "SCAR3", "GOAU4", "CPFE3", "DAGB33", "MGLU3", "ABEV3", "LMTB34", "HGCR11", "LCAM3", "TIET3", "JPMC34", "FLMA11", "GGBR4", "RNEW4", "SHOW3", "EXXO34", "RDES11", "CGRA4", "CSAN3", "ETER3", "JBDU4", "TCSA3", "IGBR3", "OGXP3", "RANI3", "EVEN3", "SSBR3", "UNIP5", "BSEV3", "ENGI3", "AGRO3", "CPTS11B", "FAMB11B", "FLRP11", "VALE3", "FAED11", "RSID3", "TRPL3", "RNEW3", "BVMF3", "ITSA3", "GUAR3", "VIVT4", "SMTO3", "SAPR3", "SMAL11", "ALSC3", "BRAP4", "FESA4", "TBOF11", "GOVE11", "EQTL3", "ALUP11", "TAEE11", "LAME3", "ABCB4", "MMXM3", "TOTS3", "MDIA3", "CPLE3", "ROMI3", "KLBN3", "BRAX11", "VIVT3", "MRVE3", "RNGO11", "CMIG3", "ITUB3", "TIET11", "FIBR3", "CSNA3", "DISB34", "EGIE3", "BOVA11", "BPFF11", "BBFI11B", "ADHM3", "IRBR3", "ALPA4", "JBSS3", "EURO11", "BBAS3", "MSFT34", "BRCR11", "VLID3", "PFIZ34", "PRIO3", "LUPA3", "CXRI11", "CGAS3", "FIIB11", "BPAC11", "RNEW11", "ATOM3", "BCRI11", "RNDP11", "VISA34", "ENBR3", "ELPL3", "GOLL4", "CIEL3", "RPMG3", "ELET3", "BMLC11B", "NATU3", "CSMG3", "SEDU3", "CPLE6", "CNES11", "ECOO11", "BOBR4", "AAPL34", "CXTL11", "RBRD11", "SMLS3", "RDNI3", "PFRM3", "CTXT11", "IDNT3", "MBRF11", "TRPL4", "ITUB4", "UGPA3", "CGAS5", "KNIP11", "ARMT34", "BALM4", "BAUH4", "BBRK3", "BOAC34", "BPAC5", "BTTL4", "CCPR3", "CCRO3", "CLSC4", "CREM3", "ESTR4", "FJTA3", "FJTA4", "GEPA3", "GOAU3", "GSHP3", "HBOR3", "JHSF3", "LLIS3", "MEND5", "MGEL4", "MNPR3", "OMGE3", "ONEF11", "PMAM3", "PMSP11B", "PNVL4", "PORD11", "RPAD6", "SCPF11", "SHUL4", "SNSL3", "TIET4", "ORCL34", "TELB3", "CBEE3", "CSCO34", "GGBR3", "SBSP3", "TRXL11", "MCDC34", "EDGA11", "ISUS11", "ANIM3", "DIRR3", "RBVO11", "LAME4", "ODPV3", "FRAS3", "RBGS11", "FRIO3", "GUAR4", "DIVO11", "UNIP3", "AEFI11", "SEER3", "LEVE3", "BBVJ11", "CTSA4", "OIBR4", "IGTA3", "JSRE11", "ABCP11", "RLOG3", "SHPH11", "KEPL3", "MXRF11", "TRIS3", "IVVB11", "ABTT34", "FVBI11", "XPCM11", "TELB4", "CMCS34", "GRND3", "RBBV11", "BEES3", "JSLG3", "QGEP3", "CEBR5", "GSGI34", "ITSA4", "CELP3", "PTBL3", "POSI3", "KNRI11", "OIBR3", "COCA34", "KLBN4", "MEAL3", "WFCO34", "LINX3", "WEGE3", "XTED11", "FIND11", "WSON33", "AGCX11", "RAIL3", "HGBS11", "JNJB34", "SPTW11", "ALPA3", "GPIV33", "LREN3", "WALM34", "MAGG3", "WHRL3", "EALT4", "FEXC11", "BBPO11", "JBDU3", "FCFL11", "MILS3", "FIGS11", "USIM5", "PDGR3", "CPRE3", "ARZZ3", "PCAR4", "KLBN11", "TIMP3", "RANI4", "MYPK3", "VIVR3", "CESP6", "CEOC11", "GFSA3", "ELET6", "HOME34", "USIM3", "SAAG11", "BMEB4", "MOVI3", "GEOO34", "PTNT4", "BPHA3", "BRKM5", "TCNO4", "POMO3", "PRML3", "VRTA11", "UCAS3", "ITLC34", "PQDP11", "HGLG11", "CRDE3", "KNCR11", "RCSL3", "THRA11", "FHER3", "PGCO34", "INEP4", "POMO4", "JFEN3", "PINE4", "HOOT4", "IDVL4", "SDIL11", "RCSL4", "MRFG3", "FLRY3", "AMAR3", "BRKM3", "BNFS11", "GBIO33", "RENT3", "PRSV11", "PARD3", "FIIP11B", "COCE5", "MMMC34", "SBUB34", "JRDM11", "HAGA4", "TEKA4", "BRSR6", "ECPR3", "SGPS3", "FFCI11", "RADL3", "LIGT3", "TPIS3", "MTSA4", "AMZO34", "HGRE11", "BBDC3", "BDLL4", "NFLX34", "DOHL4", "CBOP11", "CESP3", "BCIA11", "VLOL11", "BBDC4", "CTAX3", "BIOM3", "BRPR3", "CESP5", "AELP3", "OFSA3", "FPAB11", "BEES4", "HGJH11", "LOGN3", "TUPY3", "INEP3", "CTNM3", "MTIG4", "BMKS3", "WLMM4", "EMAE4", "MFII11", "MWET4", "CTKA4", "RBCB11", "CTNM4", "MAPT4", "CAML3", "SAPR11"


create table alarme(
 id numeric(2) not null
,validade date  
,codigo_ativo varchar(15) not null 
,valor numeric(5,2) not null
,total_notificacoes int not null
,sinal varchar(3) not null
,ultimo_envio date not null
,intervalo_reenvio numeric(3,0) not null
,PRIMARY KEY(id,codigo_ativo  )
);


create table movimento_diario(
 dia_fechamento date not null 
,codigo_ativo varchar(15) not null 
,valor numeric(5,2) not null
,PRIMARY KEY(dia_fechamento,codigo_ativo  )
)

create table movimento_diario_5M(
 dia_fechamento date not null 
,codigo_ativo varchar(15) not null 
,valor numeric(5,2) not null
,PRIMARY KEY(dia_fechamento,codigo_ativo  )
)

//////////////////////////////transfer file////////////////////////////
String encoded = Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get("C:/tmp/bolsa/teste/dados.7z")));

		File targetFile = new File("C:/tmp/bolsa/teste/stringZip.txt");
	    OutputStream outStream = new FileOutputStream(targetFile);
	    outStream.write(encoded.getBytes());
	    outStream.close();
		//////////////////////////////////////////////
	    
	    File file = new File("C:/tmp/bolsa/teste/stringZip2.txt");
	    byte[] bytesArray = new byte[(int) file.length()];
	    
	    FileInputStream fis = new FileInputStream(file);
	    fis.read(bytesArray); //read file into bytes[]
	    fis.close();
	    
	    /////////////////////////////////////
		
		// decode a String
		byte [] barr = Base64.getDecoder().decode(bytesArray); 
		
		FileUtils.writeByteArrayToFile(new File("C:/tmp/bolsa/teste/libOUT.7z"), barr);
////////////////////////////////////////////////////////////////////////////		

private static void enviarEmail() {
		Properties props = new Properties();
        /** Parâmetros de conexão com servidor Gmail */
        props.put("mail.smtp.host", "smtp.gmail.com");
        props.put("mail.smtp.socketFactory.port", "465");
        props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.port", "465");


        Session session = Session.getDefaultInstance(props,
                    new javax.mail.Authenticator() {
                         protected PasswordAuthentication getPasswordAuthentication() 
                         {
                               return new PasswordAuthentication("achieri@gmail.com", "ap260797");
                         }
                    });

        /** Ativa Debug para sessão */
        session.setDebug(true);

        try {

              Message message = new MimeMessage(session);
              message.setFrom(new InternetAddress("seuemail@gmail.com")); //Remetente

              Address[] toUser = InternetAddress //Destinatário(s)
                         .parse("achieri@gmail.com, achieri@hotmail.com");  

              message.setRecipients(Message.RecipientType.TO, toUser);
              message.setSubject("Enviando email com JavaMail");//Assunto
              message.setText("Enviei este email utilizando JavaMail com minha conta GMail!");
              /**Método para enviar a mensagem criada*/
              Transport.send(message);

              System.out.println("Feito!!!");

         } catch (MessagingException e) {
              throw new RuntimeException(e);
        }
  }
//C:\Users\t1108dgf\desenvolvimento\eclipse-jee-oxygen-1a-win32-x86_64\eclipse.exe -vm "C:\Users\t1108dgf\desenvolvimento\openjdk-1.8.0.151-1.b12\bin"

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.TreeMap;
import java.util.stream.Collectors;




public class Main {
	private static Random rand = new Random();
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	private static int[] listaValores = {50,15,20,30,50,78};
	private static Date[] datas = new Date[6];
	//private static Enum totalPeriodos
//	private static int PERIODO_1H = 60/5;
//	private static int PERIODO_1D = 24*60/5;
	
	public enum Periodo{
		PERIODO_1H(60/5), PERIODO_1D(24*60/5),PERIODO_5M(1),PERIODO_TESTE(6) ;
		
		public int totalPeriodos;
		Periodo(int periodos){
			totalPeriodos = periodos;
		}
	}

	public static void main(String[] args) throws ParseException, FileNotFoundException, IOException {
		
		List<String>listaNome = montaListaNomes();
		Map<Date, Map<String,Ativo>> mapa = obtemMapaAtivos(listaNome);
//		mapa.forEach((k,v) ->{
//			System.out.println("chave - "+k+"- valor - "+v+"-");
//			});
//		Calendar c = GregorianCalendar.getInstance();
//		c.add(Calendar.DAY_OF_MONTH, -1);
		
		// pesquisa
		Double valorMedia = obtemMedia(obtemAtivosRetroativos(Periodo.PERIODO_TESTE, listaNome.get(0), mapa));
		System.out.println("Media - "+valorMedia);
		
		Double desvioPadrao = obtemDesvioPadrao(valorMedia, mapa);
		System.out.println("Desvio padrao - "+desvioPadrao);
		
		obtemListaMaiorVariacao(mapa, Periodo.PERIODO_TESTE);
		String path="C:/tmp/bolsa/dados.txt";
		Map<Integer,String> mapaErros = validaLeituraDados(path);
		Map<Date,Map<String,Ativo>> mapaCarregado = carregaDadosArquivo(path, false, mapaErros);
		List<Alarme> listAlarme = populaAlarmes();
		disparaAlarme(listAlarme);
		
		
	}


	private static void disparaAlarme(List<Alarme> listAlarme) {
		listAlarme.stream()
			.filter(x ->"XX9".equals(x.getAtivo()) 
					&& x.getUltimoEnvio() == null || (x.getIntervaloReenvio()* 1000*60)>= System.currentTimeMillis() - x.getUltimoEnvio().getTime()
					&& x.getValidade().getTime() > System.currentTimeMillis()
					)
			.collect(Collectors.toList()).forEach(x-> System.out.println("dispara"+x));
	}
	
	
	private static List<Alarme> populaAlarmes() {
		List<Alarme> lista = new ArrayList<>();
		Calendar c = Calendar.getInstance();
		c.add(Calendar.DAY_OF_MONTH, -1);
		for(int i=0;i<10;i++){
			lista.add(new Alarme(i,(c.getTime()),"XX-"+i,Double.parseDouble("10"),1,">=",24*60*60*1000));
		}
		return lista;
	}


	private static Map<Integer,String> validaLeituraDados(String path) throws FileNotFoundException, IOException {
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String sCurrentLine;
			String[] listaCabecalho = null;
			String[] listaAtivos = null;
			boolean primeiraLinha = true;
			Map<Integer,String> mapaErros = new HashMap<>();
			int i=0;
			while ((sCurrentLine = br.readLine()) != null) {
				i++;
				if(primeiraLinha){
					listaCabecalho = sCurrentLine.replace("\"", "").split(";",0);
					primeiraLinha = false;
					continue;
				}
				listaAtivos = sCurrentLine.split(";",0);
				if(listaAtivos.length != listaCabecalho.length){
					mapaErros.put(i,"Erro na linha - "+i+" tamanho diferente do cabecalho");
				}
			}
			return mapaErros;
		}
		
	}


	private static Map<Date, Map<String, Ativo>> carregaDadosArquivo(String path, boolean isDataNow, Map<Integer, String> mapaErros) {
		Map<Date,Map<String,Ativo>> mapa = new HashMap<>();
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String sCurrentLine;
			boolean primeiraLinha = true;
			String[] listaAtivos = null;
			String[] listaCabecalho = null;
			Map<String,Ativo> mapaAtivo = null;
			Date data = Calendar.getInstance().getTime();
			int j=0;
			while ((sCurrentLine = br.readLine()) != null) {
				if(primeiraLinha){
					listaCabecalho = sCurrentLine.replace("\"", "").split(";",0);
					primeiraLinha = false;
					continue;
				}
				if(mapaErros.containsKey(j++)){
					continue;
				}
				listaAtivos = sCurrentLine.split(";",0);
				if(!isDataNow){
					try {
						data = sdf.parse(listaAtivos[0]);
					} catch (ParseException e) {
						e.printStackTrace();
					}
				}
				mapaAtivo = new HashMap<>();
				for(int i=1;i<listaAtivos.length;i++){
					mapaAtivo.put(listaCabecalho[0], new Ativo(listaCabecalho[i],data, new Double(listaAtivos[i])));
				}
				mapa.put(data, mapaAtivo);	
			}

		} catch (IOException e) {
			e.printStackTrace();
		}
		return mapa;
		
	}


	private static Map<Date, Map<String, Ativo>> obtemMapaAtivos(List<String> listaNome) {
		Map<Date, Map<String, Ativo>> map = new TreeMap<>();
		Calendar c = Calendar.getInstance();
//		c.set(Calendar.MINUTE, i*5);
		String nome = listaNome.get(0);
//		Ativo atv = new Ativo(nome,c.getTime(),listaValores[i++] );
		Map<String, Ativo> mapAtivo = new HashMap<>();
//		mapAtivo.put(nome, atv);
//		map.put(c.getTime(), mapAtivo);
		for(int i=0;i<listaValores.length;i++){
			populaLoop(i, c, nome, mapAtivo, map);
		}
//		map.put(c.getTime(), mapAtivo);
		
		return map;
	}


	private static void populaLoop(int i, Calendar c, String nome, Map<String, Ativo> mapAtivo, Map<Date, Map<String, Ativo>> map) {
		Ativo atv;
		c.set(Calendar.MINUTE, i*5);
		atv = new Ativo(nome,c.getTime(),listaValores[i] );
		mapAtivo.put(nome, atv);
		map.put(c.getTime(), mapAtivo);
		datas[i] =c.getTime(); 
	}


	private static List<Ativo> obtemListaMaiorVariacao(Map<Date, Map<String, Ativo>> mapa, Periodo p){
		Map<Date, Map<String, Ativo>> novoMapa = obtemMapaPeriodos(mapa, p);
		return new ArrayList<Ativo>();
	}
	

	private static Map<Date, Map<String, Ativo>> obtemMapaPeriodos(Map<Date, Map<String, Ativo>> mapa, Periodo p) {
		Map<Date, Map<String, Ativo>> novoMapa = new HashMap<>(); 
		Iterator<Map.Entry<Date, Map<String, Ativo>>> it = mapa.entrySet().iterator();
		int counter =0;
		List <Ativo> mapaTemp = new ArrayList<>();
		while(it.hasNext()) {
			Entry<Date, Map<String, Ativo>> map2 = it.next();
			if(++counter % p.totalPeriodos == 0 && counter > 1) {
//				Iterator<Map.Entry<String, Ativo>> it2 = mapaTemp.entrySet().iterator();
				Double valorIncial  = mapaTemp.get(0).getValorFechamento();
//				Map<String, Ativo> newMap = new TreeMap(Collections.reverseOrder());
//				newMap.putAll(mapaTemp);
				Double valorFinal = mapaTemp.get(mapaTemp.size()-1).getValorFechamento();
				
				System.out.println((valorIncial/valorFinal)*100);
//				while(it2.hasNext()) {
//					mapAtivosOld = it2.next();
//					Map<String, Ativo> mapaAtivo = new HashMap<>();
////					mapaAtivo.put(map2.getValue(), value)
////					novoMapa.put(map2.getKey(), value)
//				}
			}else {
				Ativo ativoTmp = map2.getValue().entrySet().stream().findFirst().get().getValue();
				mapaTemp.add(ativoTmp);
			}
			
		}
		for(int i=0;i<mapa.size();i++) {
			int totalBloco = (mapa.size()> i+p.totalPeriodos)?p.totalPeriodos:mapa.size() - (p.totalPeriodos-i);

		}
		return null;
	}


	private static Double obtemDesvioPadrao(Double valorMedia, Map<Date, Map<String, Ativo>> mapa) {
		double[] desvioPadrao = {0};
		mapa.entrySet().forEach(v -> v.getValue().entrySet().forEach(v1 ->{
			desvioPadrao[0] +=Math.pow((v1.getValue().getValorFechamento() - valorMedia),2);
//			System.out.println(desvioPadrao[0]);
		}));
//		Iterator<Map.Entry<Date, Map<String, Ativo>>> it = mapa.entrySet().iterator();
//		while(it.hasNext()) {
//			Entry<Date, Map<String, Ativo>> map2 = it.next();
//			Iterator<Map.Entry<String, Ativo>> it2 = map2.getValue().entrySet().iterator();	
//			while(it2.hasNext()) {
//				Ativo atv = it2.next().getValue();
//				desvioPadrao[0] +=Math.pow((atv.getValorFechamento() - valorMedia),2);
//				System.out.println(atv.getValorFechamento()+"-"+Math.pow((atv.getValorFechamento() - valorMedia),2)+"-"+desvioPadrao[0]);
//				System.out.println();
//			}
//		}
		return Math.sqrt(desvioPadrao[0]/mapa.size());
	}





	private static Double obtemMedia(Map<Date, Ativo> mapa) {
//		return mapa.values().stream().collect(Collectors.summarizingDouble(Ativo::getValorFechamento)).getSum()/mapa.size();
		double valor = 0;
		Iterator<Map.Entry<Date, Ativo>> it = mapa.entrySet().iterator();
		while(it.hasNext()){
			valor += it.next().getValue().getValorFechamento();
		}
		return new Double(valor)/mapa.size();
		
	}





	private static Map<Date,Ativo> obtemAtivosRetroativos(Periodo periodo, String nomeAtivo, Map<Date, Map<String,Ativo>> mapa) throws ParseException {
		Map<Date,Ativo> map = new TreeMap<>();
		Calendar c = null;
		for(int i=0;i<periodo.totalPeriodos;i++) {
//			c = GregorianCalendar.getInstance();
//			c.add(Calendar.DAY_OF_MONTH, -i);
//			Date data = sdf.parse(sdf.format(c.getTime()));
			map.put(datas[i],mapa.get(datas[i]).get(nomeAtivo));
			// TODO esta correto acima
//			map.put(new Date(),mapa.get(data).get(nomeAtivo));
		}
		return map;
	}



	private static List<String> montaListaNomes() {
		List<String> lista = new ArrayList<>();
		for(int i=0;i<40;i++) {
			lista.add(String.valueOf((char)(rand.nextInt(200)+64)+(char)(rand.nextInt(200)+64)));
		}
		return lista;
	}

//	private static Map<Date, Map<String,Ativo>> obtemMapaAtivos(List<String> listaNome) throws ParseException {
//		Ativo at = null;
//		SortedMap <Date, Map<String,Ativo>> mapa = new TreeMap<>();
//		
//		for(int i=0;i<listaValores.length;i++) {
//			Map<String,Ativo> mapaAtivo = new HashMap<>();
//			Calendar c = GregorianCalendar.getInstance();
//			c.add(Calendar.DAY_OF_MONTH, -i);
//			for(int j=0;j<1;j++) {
//				at = new Ativo();
//				at.setValorFechamento(Double.valueOf(listaValores[i]));
//				at.setCodAtivo(listaNome.get(0));
//				at.setData(c.getTime());
//				mapaAtivo.put(listaNome.get(0), at);
//			}
//			mapa.put(sdf.parse(sdf.format(c.getTime())),mapaAtivo);
//		}
//		return mapa;
//	}

	

}
class Ativo{
	private Double taxaVariacao;
	private Double valorFechamento;
	private String codAtivo;
	private Date data;
	
	
	
	public Ativo(String nome, Date data, double valor) {
		this.setCodAtivo(nome);
		this.setData(data);
		this.setValorFechamento(Double.valueOf(valor));
	}
	public Date getData() {
		return data;
	}
	public void setData(Date data) {
		this.data = data;
	}
	public Double getTaxaVariacao() {
		return taxaVariacao;
	}
	public void setTaxaVariacao(Double taxaVariacao) {
		this.taxaVariacao = taxaVariacao;
	}
	public String getCodAtivo() {
		return codAtivo;
	}
	public void setCodAtivo(String codAtivo) {
		this.codAtivo = codAtivo;
	}
	public Double getValorFechamento() {
		return valorFechamento;
	}
	public void setValorFechamento(Double valorFechamento) {
		this.valorFechamento = valorFechamento;
	}
}
	
class Alarme{
//		id numeric(2) not null
//		,validade date  
//		,codigo_ativo varchar(15) not null 
//		,valor numeric(5,2) not null
//		,total_notificacoes int not null
//		,sinal varchar(2) not null
//		,ultimo_alarme date not null
//		,intervalo_reenvio numeric(2,0) not null
		private Integer id;
		private Date validade;
		private String ativo;
		private Double valor;
		private Integer totalNotificacoes;
		private String sinal;
		private Date ultimoEnvio;
		private Integer intervaloReenvio;
		public Alarme(int id, Date validade, String ativo, Double valor, int totalNotificacoes
				, String sinal, int intervaloReenvio){
			this.ativo = ativo;
			this.id = id;
			this.intervaloReenvio = intervaloReenvio;
			this.sinal = sinal;
			this.totalNotificacoes = totalNotificacoes;
			this.validade = validade;
			this.valor = valor;
		}
		public Integer getId() {
			return id;
		}
		public void setId(Integer id) {
			this.id = id;
		}
		public Date getValidade() {
			return validade;
		}
		public void setValidade(Date validade) {
			this.validade = validade;
		}
		public String getAtivo() {
			return ativo;
		}
		public void setAtivo(String ativo) {
			this.ativo = ativo;
		}
		public Double getValor() {
			return valor;
		}
		public void setValor(Double valor) {
			this.valor = valor;
		}
		public Integer getTotalNotificacoes() {
			return totalNotificacoes;
		}
		public void setTotalNotificacoes(Integer totalNotificacoes) {
			this.totalNotificacoes = totalNotificacoes;
		}
		public String getSinal() {
			return sinal;
		}
		public void setSinal(String sinal) {
			this.sinal = sinal;
		}
		public Date getUltimoEnvio() {
			return ultimoEnvio;
		}
		public void setUltimoEnvio(Date ultimoEnvio) {
			this.ultimoEnvio = ultimoEnvio;
		}
		public Integer getIntervaloReenvio() {
			return intervaloReenvio;
		}
		public void setIntervaloReenvio(Integer intervaloReenvio) {
			this.intervaloReenvio = intervaloReenvio;
		}
}
